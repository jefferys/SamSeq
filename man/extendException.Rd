% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exceptions.R
\name{extendException}
\alias{extendException}
\title{Create a new exception from an existing one.}
\usage{
extendException(exception, base = Exception())
}
\arguments{
\item{exception}{The new exception's class (name). Usually just a single
class, but can be a vector of classes. This is prepended to the class
vector of the \code{base} exception to create the complete class of the
new exception}

\item{base}{An existing exception to base a new exception on. Often
constructed in-line to allow setting parameters. By default this is the
exception generated by a no-parameter call to "Exception()."}
}
\value{
\code{extendException} returns a new exception class inheriting the
  \code{message}, \code{call}, and class hierarchy of the \code{base=}
  exception, and all of that base class's data elements.
}
\description{
This is used mainly to create exception constructors. Given a base exception,
this builds a new exception based on it. The base exception is usually
constructed inline as the \code{message}, \code{call}, \code{package}, and
any data properties in the new exception are inherited from the base
exception. They can only be set when the base exception is constructed and
can not be overriden by this extension constructor. The new exception can
have any additional specified exception class(es), but will also inherit the
classes of the base exception.
}
\details{
It is not recommended to use \code{"extendException"} to directly create new
exceptions unless those exceptions are documented and used only in one place.
Repeatedly constructing the same class of exception is the job of a
constructor function, and an exception constructor function provides an
obvious place to put documentation.
}
\examples{
# Function to create a new FruitException
FruitException <- function( fruit,
    message= sprintf("Sorry, \%s is a fruit", fruit),
    call=NULL, package= packageName(), ...
){
   e <- extendException( c("FruitException", "PedanticException"),
      base= Exception( message=message, call= call, package= package,
         fruit= fruit, ...)
   )
   return(e)
}

fEx <- FruitException( fruit= "tomato" )
inherits(fEx, "FruitException")
inherits(fEx, "PedanticException")
inherits(e, "Exception")
inherits(e, "condition")
fEx$fruit == "tomato"   # Internal use only

# Making fruit accessible by external users.
exceptionFruit <- function(...)  UseMethod( "exceptionFruit" )
exceptionFruit.Exception(e, ...) e$fruit

exceptionFruit( fEx )

# Will work for any Exception derived object
ex <- Exception( fruit= "Green Pepper", package="testing" )
exceptionFruit( ex ) == ex$fruit
conditionMessage( ex ) == "[testing] An Exception occurred."

# Can use data variables in messages
ex <- Exception( message= paste0( "I hate ", fruit ),
   fruit= "Green Pepper", package="testing")
conditionMessage( ex ) == "[testing] I hate Green Pepper."

\dontrun{
   # User putting in extra data for internal use
   withComplainerFEx <- FruitException( fruit= "tomato", complainer= "Bob")
   tryCatch(
      { stop(withComplainerFEx) },
      FruitException= function(e) {
         if (e$complainer == "Bob") {
            message(paste0( "Ignoring Bob's complaint: \\"",
                            conditionMessage(e), "\\"" ))
         }
      }
   )
}

}

