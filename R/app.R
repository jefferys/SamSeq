
getOptionSpec <- function() {
	return( list(
		optargs::make_option(
			c("-i", "--inFile"), type= "character", metavar= "FILE",
			default= NULL,
			help= paste0(
				"If not given as an argument (IN_FILE), the input file can\n",
				"\t\t", "be specified via this option.\n",
				"\t\t", "It is an error to do both."
			)
		),
		optargs::make_option(
			c("-o", "--outFile"), type= "character", metavar= "FILE",
			default= "junction.tsv",
			help= paste0(
				"Output junction file. [Default: %default]\n",
				"\t\tIt is an error if the output file already already exists,\n",
				"\t\tunless this is a --rerun."
			)
		),
		optargs::make_option(
			c("-r", "--rerun"), action= "store_true", default= FALSE,
			help= "Add flag if this is a rerun (allows over-writing output)."
		),
		optargs::make_option(
			c("-d", "--outDir"), type= "character", metavar="DIR",
			default= getwd(),
			help= paste0(
				"Output directory. [Default: current dir]\n",
				"\t\tMay be absolute or relative (to the current directory.)\n",
				"\t\tErrors if more than 1 directory level must be created."
			)
		),
		optargs::make_option(
			c("-l", "--logFile"), type= "character", metavar= "FILE",
			default= "viralSite.log",
			help= paste0(
				"Log file name. [Default: %default]\n",
				"\t\tCreated if needed, otherwise appends to existing file.\n",
				"\t\tSet --logFileLevel to OFF if don't want to log to a file.\n",
				"\t\tIgnores --rerun."
			)
		),
		optargs::make_option(
			c("--logFileLevel"), type= "character", metavar= "LOG_LEVEL",
			default= "INFO",
			help= paste0(
				"Log file logging level. [Default: %default]\n",
				"\t\tMessages with level >= this are logged to --logFile.\n",
				"\t\tIn decreasing priority order, one of:\n",
				"\t\tOFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE"
			)
		),
		optargs::make_option(
			c("--logConsoleLevel"), type= "character", metavar= "LOG_LEVEL",
			default= "INFO",
			help= paste0(
				"Console (stdout) logging level. [Default: %default]\n",
				"\t\tMessages with level >= this are printed to stdout.\n",
				"\t\tIn decreasing priority order, one of:\n",
				"\t\tOFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE"
			)
		)
	))
}
getOptionParser <- function() {
	return( optargs::OptionParser(
		getOptionSpec(),
		add_help_option= TRUE, prog= "viralSite",
		usage= "usage: %prog [options] IN_FILE\n",
		description= paste0(
			"Arguments:\n",
			"\tIN_FILE\n",
			"\t\tThe input sam file, with chimeric reads.\n",
			"\t\tE.g. the chimeric *.sam file generated by STAR.\n",
			"\t\tRequired unless specified as --inFile instead."
		)
	))
}
getRawOpts <- function() {
	return( optargs::parse_args(
			getOptionParser(),
			positional_arguments= TRUE
	))
}
getCleanOpts <- function( opts= getRawOpts(), parser= getOptionParser() ) {

	# Check for unknown options (they are captured as arguments)
	if( length(opts$args) > 0 && any(substr(opts$args, 1,1) == '-')) {
		optparser::print_help(parser)
		stop( paste( "\tUnknown option:",
						 opts$args[substr(opts$args, 1,1) == '-'],
						 collapse="\n"
		), call.=FALSE
		)
	}

	### IN_FILE argument
	# Can't be specified twice
	if (! is.null (opts$options$inFile ) && length( opts$args )  > 0 ) {
		optparser::print_help(parser)
		stop( "Input file specified twice. Use either an argument ",
				"or the --inFile option, but not both.",
				call.=FALSE )
	}
	# If argument, move to options
	if ( is.null( opts$options$inFile ) && length( opts$args )  > 0 ) {
		opts$options$inFile <- opts$args[1]
	}

	### All arguments handled and converted to options, simplify options access
	opts <- opts$options

	### --inFile (possibly from IN_FILE)
	# Must be specified
	if (is.null( opts$inFile )) {
		optparser::print_help( parser )
		stop( "Input file is required.",
				"Specify as an argument or the --inFile option (not both)",
				call.=FALSE
		)
	}
	# Must exist
	if (! file.exists( opts$inFile )) {
		optparser::print_help( parser )
		stop( NoSuchFileException( opts$inFile))
	}
	# Must be a file (not a directory)
	if (dir.exists( opts$inFile)) {
		optparser::print_help( parser )
		stop( DirectoryExistsException( opts$inFile ))
	}

	### --outFile
	return(opts$options)
}

run <- function() {

}

#' Run the viralSite analysis
#'
#' @return Nothing, called for the side effect of running the analysis.
#'
#' @export
viralSite <- function() {
	opts <- getCleanOpts()
	initSayLoggers( file= opts$logFile, fileLevel= opts$logFileLevel,
						 consoleLevel= opts$logConsoleLevel )
	sayDebug( "Initialized Application" )
	sayDebug( "Parsed options:"
				 %pp% paste(names(opts), opts[names(opts)], sep="= ", collapse="; " ))
	samObj <- Sam( file= opts$inFile )

}
